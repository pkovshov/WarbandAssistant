smoke: commands[0]> pytest --doctest-modules --ignore tests/test_parsing_by_datasets --ignore utils/map_calendars_add_overlapped.py --ignore tox.py
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
cachedir: .tox/smoke/.pytest_cache
rootdir: /sandbox/MountAndBladeWarband/WarbandAssistant
plugins: cases-3.9.1, typeguard-4.4.4
collecting ... collecting 20 items                                                            collecting 20 items                                                            collected 25 items                                                             

src/wa_language/KeyChecker.py .                                          [  4%]
src/wa_language/LangKey.py .                                             [  8%]
src/wa_language/semantics_test.py ....F..F.                              [ 44%]
src/wa_language/syntax/Interpolation.py .                                [ 48%]
src/wa_language/syntax/parser.py .....                                   [ 68%]
src/wa_language/syntax/syntax_test.py .                                  [ 72%]
src/wa_types/Box.py ..                                                   [ 80%]
tests/datasets_test.py .....                                             [100%]

=================================== FAILURES ===================================
_______________________ test_bind_with_dict_lang_values ________________________

    def test_bind_with_dict_lang_values():
        lang = RootLanguage({
            "tst_key": "As you wish, {sire/my lady}. {reg6?I:{reg7?{Sir/Lady}, you:{s11}}} will be the new {reg3?lady:lord} of {s1}.",
        })
        lang_value = next(iter(lang.values()))
>       male_value = lang_value.bind(Binding({PlayerSexVar: PlayerSex.MALE, LangVar("reg7"): True}))

src/wa_language/semantics_test.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/wa_language/LangValue.py:79: in bind
    return self._bind_with_binding(args[0])
src/wa_language/LangValue.py:135: in _bind_with_binding
    binding = dict(binding)
.tox/smoke/lib/python3.10/site-packages/typeguard/_functions.py:283: in check_variable_assignment
    check_type_internal(val, annotation, memo)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = {PlayerSexVar: PlayerSex.MALE, LangVar('reg7'): True}
annotation = <class 'wa_language.Binding.Binding'>
memo = <typeguard.TypeCheckMemo object at 0x7f28da3a36c0>

    def check_type_internal(
        value: Any,
        annotation: Any,
        memo: TypeCheckMemo,
    ) -> None:
        """
        Check that the given object is compatible with the given type annotation.
    
        This function should only be used by type checker callables. Applications should use
        :func:`~.check_type` instead.
    
        :param value: the value to check
        :param annotation: the type annotation to check against
        :param memo: a memo object containing configuration and information necessary for
            looking up forward references
        """
    
        if isinstance(annotation, ForwardRef):
            try:
                annotation = evaluate_forwardref(annotation, memo)
            except NameError:
                if memo.config.forward_ref_policy is ForwardRefPolicy.ERROR:
                    raise
                elif memo.config.forward_ref_policy is ForwardRefPolicy.WARN:
                    warnings.warn(
                        f"Cannot resolve forward reference {annotation.__forward_arg__!r}",
                        TypeHintWarning,
                        stacklevel=get_stacklevel(),
                    )
    
                return
    
        if annotation is Any or annotation is SubclassableAny or isinstance(value, Mock):
            return
    
        # Skip type checks if value is an instance of a class that inherits from Any
        if not isclass(value) and SubclassableAny in type(value).__bases__:
            return
    
        extras: tuple[Any, ...]
        origin_type = get_origin(annotation)
        if origin_type is Annotated:
            annotation, *extras_ = get_args(annotation)
            extras = tuple(extras_)
            origin_type = get_origin(annotation)
        else:
            extras = ()
    
        if origin_type is not None:
            args = get_args(annotation)
    
            # Compatibility hack to distinguish between unparametrized and empty tuple
            # (tuple[()]), necessary due to https://github.com/python/cpython/issues/91137
            if origin_type in (tuple, Tuple) and annotation is not Tuple and not args:
                args = ((),)
        else:
            origin_type = annotation
            args = ()
    
        for lookup_func in checker_lookup_functions:
            checker = lookup_func(origin_type, args, extras)
            if checker:
                checker(value, origin_type, args, memo)
                return
    
        if isclass(origin_type):
            if not isinstance(value, origin_type):
>               raise TypeCheckError(f"is not an instance of {qualified_name(origin_type)}")
E               typeguard.TypeCheckError: value assigned to binding (dict) is not an instance of wa_language.Binding.Binding

.tox/smoke/lib/python3.10/site-packages/typeguard/_checkers.py:965: TypeCheckError
____________________ test_purge_spread_with_unbind_sex_var _____________________

    def test_purge_spread_with_unbind_sex_var():
        lang = RootLanguage({
            "tst_key": "As you wish, {sire/my lady}. {reg6?I:Wee} glad to see {s11}",
        })
        lang_value = next(iter(lang.values()))
>       purge_spread = sorted(lang_value.purge_spread())

src/wa_language/semantics_test.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/wa_language/LangValue.py:117: in purge_spread
    return self.bind(binding).spread(spreading)
src/wa_language/LangValue.py:79: in bind
    return self._bind_with_binding(args[0])
src/wa_language/LangValue.py:135: in _bind_with_binding
    binding = dict(binding)
.tox/smoke/lib/python3.10/site-packages/typeguard/_functions.py:283: in check_variable_assignment
    check_type_internal(val, annotation, memo)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = {LangVar('s11'): ''}, annotation = <class 'wa_language.Binding.Binding'>
memo = <typeguard.TypeCheckMemo object at 0x7f28dbd87c80>

    def check_type_internal(
        value: Any,
        annotation: Any,
        memo: TypeCheckMemo,
    ) -> None:
        """
        Check that the given object is compatible with the given type annotation.
    
        This function should only be used by type checker callables. Applications should use
        :func:`~.check_type` instead.
    
        :param value: the value to check
        :param annotation: the type annotation to check against
        :param memo: a memo object containing configuration and information necessary for
            looking up forward references
        """
    
        if isinstance(annotation, ForwardRef):
            try:
                annotation = evaluate_forwardref(annotation, memo)
            except NameError:
                if memo.config.forward_ref_policy is ForwardRefPolicy.ERROR:
                    raise
                elif memo.config.forward_ref_policy is ForwardRefPolicy.WARN:
                    warnings.warn(
                        f"Cannot resolve forward reference {annotation.__forward_arg__!r}",
                        TypeHintWarning,
                        stacklevel=get_stacklevel(),
                    )
    
                return
    
        if annotation is Any or annotation is SubclassableAny or isinstance(value, Mock):
            return
    
        # Skip type checks if value is an instance of a class that inherits from Any
        if not isclass(value) and SubclassableAny in type(value).__bases__:
            return
    
        extras: tuple[Any, ...]
        origin_type = get_origin(annotation)
        if origin_type is Annotated:
            annotation, *extras_ = get_args(annotation)
            extras = tuple(extras_)
            origin_type = get_origin(annotation)
        else:
            extras = ()
    
        if origin_type is not None:
            args = get_args(annotation)
    
            # Compatibility hack to distinguish between unparametrized and empty tuple
            # (tuple[()]), necessary due to https://github.com/python/cpython/issues/91137
            if origin_type in (tuple, Tuple) and annotation is not Tuple and not args:
                args = ((),)
        else:
            origin_type = annotation
            args = ()
    
        for lookup_func in checker_lookup_functions:
            checker = lookup_func(origin_type, args, extras)
            if checker:
                checker(value, origin_type, args, memo)
                return
    
        if isclass(origin_type):
            if not isinstance(value, origin_type):
>               raise TypeCheckError(f"is not an instance of {qualified_name(origin_type)}")
E               typeguard.TypeCheckError: value assigned to binding (dict) is not an instance of wa_language.Binding.Binding

.tox/smoke/lib/python3.10/site-packages/typeguard/_checkers.py:965: TypeCheckError
=========================== short test summary info ============================
FAILED src/wa_language/semantics_test.py::test_bind_with_dict_lang_values - typeguard.TypeCheckError: value assigned to binding (dict) is not an instan...
FAILED src/wa_language/semantics_test.py::test_purge_spread_with_unbind_sex_var - typeguard.TypeCheckError: value assigned to binding (dict) is not an instan...
========================= 2 failed, 23 passed in 3.84s =========================
smoke: exit 1 (4.12 seconds) /sandbox/MountAndBladeWarband/WarbandAssistant> pytest --doctest-modules --ignore tests/test_parsing_by_datasets --ignore utils/map_calendars_add_overlapped.py --ignore tox.py pid=29023
smoke: FAIL ✖ in 4.15 seconds
dialog_bodies: commands[0]> pytest tests/test_parsing_by_datasets/dialog_body_by_dataset_test.py
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
cachedir: .tox/dialog_bodies/.pytest_cache
rootdir: /sandbox/MountAndBladeWarband/WarbandAssistant
plugins: cases-3.9.1, typeguard-4.4.4
collecting ... collecting 0 items / 1 error                                                   collected 0 items / 1 error                                                    


total time    : 0.9982 sec
collec time   : 0.9592 sec
setups time   : 0.0000 sec
calls time    : 0.0000 sec
passed        : 0 / 0
==================================== ERRORS ====================================
_ ERROR collecting tests/test_parsing_by_datasets/dialog_body_by_dataset_test.py _
tests/test_parsing_by_datasets/dialog_body_by_dataset_test.py:28: in <module>
    male_parser = DialogBodyFuzzyParser(lang, PlayerSex.MALE)
src/wa_screen_manager/DialogScreen/DialogBodyFuzzyParser.py:17: in __init__
    self.__dialog_body_model = DialogBodyModel(language=lang,
src/wa_model/dialog_model/DialogBodyModel.py:32: in __init__
    self.__build()
src/wa_model/dialog_model/DialogBodyModel.py:97: in __build
    self.__add_kings_bodies()
src/wa_model/dialog_model/DialogBodyModel.py:56: in __add_kings_bodies
    king_body_model = LanguageModel(
src/wa_language/LanguageModel.py:47: in __init__
    self.__language[key] = val.bind(player_name_sex_binding)
src/wa_language/LangValue.py:79: in bind
    return self._bind_with_binding(args[0])
src/wa_language/LangValue.py:135: in _bind_with_binding
    binding = dict(binding)
.tox/dialog_bodies/lib/python3.10/site-packages/typeguard/_functions.py:283: in check_variable_assignment
    check_type_internal(val, annotation, memo)
.tox/dialog_bodies/lib/python3.10/site-packages/typeguard/_checkers.py:965: in check_type_internal
    raise TypeCheckError(f"is not an instance of {qualified_name(origin_type)}")
E   typeguard.TypeCheckError: value assigned to binding (dict) is not an instance of wa_language.Binding.Binding
=========================== short test summary info ============================
ERROR tests/test_parsing_by_datasets/dialog_body_by_dataset_test.py - typeguard.TypeCheckError: value assigned to binding (dict) is not an instan...
!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
=============================== 1 error in 1.03s ===============================
dialog_bodies: exit 2 (1.21 seconds) /sandbox/MountAndBladeWarband/WarbandAssistant> pytest tests/test_parsing_by_datasets/dialog_body_by_dataset_test.py pid=29163
dialog_bodies: FAIL ✖ in 1.21 seconds
dialog_titles: commands[0]> pytest tests/test_parsing_by_datasets/dialog_title_by_dataset_test.py
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
cachedir: .tox/dialog_titles/.pytest_cache
rootdir: /sandbox/MountAndBladeWarband/WarbandAssistant
plugins: cases-3.9.1, typeguard-4.4.4
collecting ... collecting 232 items                                                           collected 232 items                                                            

tests/test_parsing_by_datasets/dialog_title_by_dataset_test.py ......... [  3%]
........................................................................ [ 34%]
........................................................................ [ 65%]
........................................................................ [ 96%]
.......                                                                  [100%]

total time    : 21.2065 sec
collec time   : 1.9395 sec
setups time   : 0.0559 sec
calls time    : 19.0817 sec
avg call time : 0.0822 sec
passed        : 232 / 232

============================= 232 passed in 21.21s =============================
dialog_titles: OK ✔ in 21.48 seconds
dialog_relations: commands[0]> pytest tests/test_parsing_by_datasets/dialog_relation_by_dataset_test.py
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
cachedir: .tox/dialog_relations/.pytest_cache
rootdir: /sandbox/MountAndBladeWarband/WarbandAssistant
plugins: cases-3.9.1, typeguard-4.4.4
collecting ... collecting 40 items                                                            collected 40 items                                                             

tests/test_parsing_by_datasets/dialog_relation_by_dataset_test.py ...... [ 15%]
..................................                                       [100%]

total time    : 4.0040 sec
collec time   : 0.8446 sec
setups time   : 0.0096 sec
calls time    : 3.1273 sec
avg call time : 0.0782 sec
passed        : 40 / 40

============================== 40 passed in 4.00s ==============================
dialog_relations: OK ✔ in 4.23 seconds
map_calendars: commands[0]> pytest tests/test_parsing_by_datasets/map_calendar_by_dataset_test.py
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
cachedir: .tox/map_calendars/.pytest_cache
rootdir: /sandbox/MountAndBladeWarband/WarbandAssistant
plugins: cases-3.9.1, typeguard-4.4.4
collecting ... collecting 0 items / 1 error                                                   collected 0 items / 1 error                                                    


total time    : 0.9039 sec
collec time   : 0.8642 sec
setups time   : 0.0000 sec
calls time    : 0.0000 sec
passed        : 0 / 0
==================================== ERRORS ====================================
_ ERROR collecting tests/test_parsing_by_datasets/map_calendar_by_dataset_test.py _
tests/test_parsing_by_datasets/map_calendar_by_dataset_test.py:28: in <module>
    date_model = LanguageModel(model=calendar_model.date_model,
src/wa_language/LanguageModel.py:57: in __init__
    self.__purge_spread = tuple(purge_spread)
src/wa_language/LanguageModel.py:55: in <genexpr>
    purge_spread = itertools.chain.from_iterable(
src/wa_language/LanguageModel.py:51: in <genexpr>
    val.purge_spread() for val in self.__language.values())
src/wa_language/LangValue.py:117: in purge_spread
    return self.bind(binding).spread(spreading)
src/wa_language/LangValue.py:79: in bind
    return self._bind_with_binding(args[0])
src/wa_language/LangValue.py:135: in _bind_with_binding
    binding = dict(binding)
.tox/map_calendars/lib/python3.10/site-packages/typeguard/_functions.py:283: in check_variable_assignment
    check_type_internal(val, annotation, memo)
.tox/map_calendars/lib/python3.10/site-packages/typeguard/_checkers.py:965: in check_type_internal
    raise TypeCheckError(f"is not an instance of {qualified_name(origin_type)}")
E   typeguard.TypeCheckError: value assigned to binding (dict) is not an instance of wa_language.Binding.Binding
=========================== short test summary info ============================
ERROR tests/test_parsing_by_datasets/map_calendar_by_dataset_test.py - typeguard.TypeCheckError: value assigned to binding (dict) is not an instan...
!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
=============================== 1 error in 0.92s ===============================
map_calendars: exit 2 (1.13 seconds) /sandbox/MountAndBladeWarband/WarbandAssistant> pytest tests/test_parsing_by_datasets/map_calendar_by_dataset_test.py pid=30660
  smoke: FAIL code 1 (4.15=setup[0.03]+cmd[4.12] seconds)
  dialog_bodies: FAIL code 2 (1.21=setup[0.00]+cmd[1.21] seconds)
  dialog_titles: OK (21.48=setup[0.00]+cmd[21.48] seconds)
  dialog_relations: OK (4.23=setup[0.00]+cmd[4.23] seconds)
  map_calendars: FAIL code 2 (1.13=setup[0.00]+cmd[1.13] seconds)
  evaluation failed :( (32.26 seconds)

